#pragma once

#include "genome.h"
#include "iteratorRange.h"
#include <string>
#include <vector>
#include <initializer_list>
#include <unordered_map>

namespace genetic {
namespace grammar {
	
/// This structure defines a type of a node in a GP tree.
struct Type {
protected:
	const char *name;
	// Intialized by the grammar.
	TreeGenomeType typeId;
	friend struct Grammar;
public:
	/// Useful for validation.
	static constexpr TreeGenomeType invalidTypeId = std::numeric_limits<TreeGenomeType>::max();
	
	constexpr Type(const char *name) : typeId(invalidTypeId), name(name) {
	}

	const char *getName() const {
		return name;
	}

	TreeGenomeType getTypeValue() const {
		assert(typeId != invalidTypeId && "Unitialized type");
		return typeId;
	}
};

/// This structure defines the grammar for a terminal or a function node in a GP tree.
struct Definition {
	enum class Kind {
		Terminal,
		Function
	};
	enum Flag: unsigned {
		// This node can't be generated by the generator.
		Restricted = 0x1
	};
protected:
	/// Is this node a terminal or a function.
	Kind kind;
	/// The name of this node.
	const char *name;
	/// The typename of this node.
	const char *typeName;
	std::vector<const char *> argumentTypeNames;
	/// The relative probability of this node generated.
	TreeGenomeValue weight;
	/// The number of arguments that a function node has, 0 if this is a terminal node.
	unsigned numArguments;

	/// These properties are computed by the grammar.
	TreeGenomeValue rawValue;
	unsigned nodeId;
	TreeGenomeType typeId;
	std::vector<TreeGenomeType> argumentTypeIds;
	friend struct Grammar;
public:

	Definition(Kind kind, const char *name, const Type &type, std::initializer_list<Type> argumentTypes, TreeGenomeValue weight, unsigned numArguments) : kind(kind), name(name), typeName(type.getName()), weight(weight), numArguments(numArguments), rawValue(), nodeId(0), typeId(Type::invalidTypeId) {
		for (auto &&type : argumentTypes) {
			argumentTypeNames.push_back(type.getName());
		}
	}

	bool isTerminal() const {
		return kind == Kind::Terminal;
	}

	bool isFunction() const {
		return kind == Kind::Function;
	}

	unsigned getNumArguments() const {
		return numArguments;
	}

	const char *getName() const {
		return name;
	}

	unsigned getDefinitionId() const {
		assert(typeId != Type::invalidTypeId && "Unitialized declaration");
		return nodeId;
	}

	TreeGenomeValue getWeight() const {
		return weight;
	}

	TreeGenomeValue getNodeValue() const {
		assert(typeId != Type::invalidTypeId && "Unitialized declaration");
		return rawValue;
	}
	
	TreeGenomeType getType() const {
		assert(typeId != Type::invalidTypeId && "Unitialized declaration");
		return typeId;
	}

	TreeGenomeType getTypeForArgument(unsigned i) const {
		assert(typeId != Type::invalidTypeId && "Unitialized declaration");
		assert(i < numArguments);
		return argumentTypeIds[i];
	}
};

// A set of definitions for a specific name.
struct DefinitionSet {
	std::vector<unsigned> definitionIDs;
public:
	DefinitionSet() {}
	explicit DefinitionSet(std::vector<unsigned> definitionIDs) : definitionIDs(std::move(definitionIDs)) { }
	DefinitionSet(DefinitionSet &&other) : definitionIDs(std::move(other.definitionIDs)) { }
	
	DefinitionSet &operator = (DefinitionSet &&other) {
		definitionIDs = std::move(other.definitionIDs);
		return *this;
	}
	
	bool contains(unsigned definitionID) const {
		for (auto x : definitionIDs) {
			if (x == definitionID) {
				return true;
			}
		}
		return false;
	}
	
	bool isEmpty() const {
		return definitionIDs.empty();
	}
	
	unsigned singleDefinition() const {
		assert(definitionIDs.size() == 1);
		return definitionIDs[0];
	}
};
	
// This structure defines the grammar for a GP tree.
struct Grammar {
	// This structure defines how to generate type specific nodes and allows them to be mapped
	// to correct, grammar specific nodes.
	struct TypeDefinitionSet {
	private:
		TreeGenomeValue terminalLimit, functionLimit;
		TreeGenomeValue terminalOffset, functionOffset;
	public:
		TypeDefinitionSet(TreeGenomeValue terminalLimit, TreeGenomeValue functionLimit, TreeGenomeValue terminalOffset, TreeGenomeValue functionOffset) : terminalLimit(terminalLimit), functionLimit(functionLimit), terminalOffset(terminalOffset), functionOffset(functionOffset) {
		}

		bool hasTerminals() const {
			return terminalLimit != 0;
		}
		
		bool hasFunctions() const {
			return functionLimit > terminalLimit;
		}
		
		TreeGenomeValue typeConstrainedTerminalLimit() const {
			return terminalLimit;
		}
		
		TreeGenomeValue typeConstrainedFunctionLimit() const {
			return functionLimit;
		}
	
		// Converts a type constrained node value into a correct, grammar constrained node value.
		TreeGenomeValue nodeValueForTypeConstrainedNodeValue(TreeGenomeValue value) const {
			if (value < terminalLimit) {
				return value + terminalOffset;
			}
			assert(value < functionLimit);
			return (value - terminalLimit) + functionOffset;
		}
	};
private:
	std::vector<Type> types;
	std::vector<Definition> nodes;
	struct TypePartion {
		size_t terminalBegin = 0, terminalCount = 0;
		size_t functionBegin = 0, functionCount = 0;
	};
	std::vector<TypePartion> typePartions;
	std::vector<TypeDefinitionSet> definitionSets;
	// Definition set unconstrained by types.
	TypeDefinitionSet globalDefinitionSet;
	std::unordered_map<std::string, TreeGenomeType> typeMappings;
	
	unsigned terminalCount, terminalAndFunctionCount;
	TreeGenomeValue terminalLimit, functionLimit, nodeLimit;
	TreeGenomeValue validNodeLimit;
public:

	Grammar(std::initializer_list<Type> types, std::initializer_list<Definition> nodes) : nodes(), globalDefinitionSet(0,0,0,0), typeMappings() {
		// Set up the types.
		unsigned typeId = 0;
		for (auto type : types) {
			assert(type.typeId == Type::invalidTypeId);
			type.typeId = typeId;
			// FIXME: Verify type names are unique.
			auto inserted = typeMappings.insert(std::make_pair(std::string(type.getName()), typeId)).second;
			if (!inserted) {
				assert(false && "Duplicate type name");
			}
			this->types.push_back(type);
			typeId += 1;
		}
		auto findTypeId = [&] (const char *typeName) -> TreeGenomeType {
			auto it = typeMappings.find(typeName);
			if (it == typeMappings.end()) {
				// FIXME: make error.
				assert(false && "Error: type isn't present in the grammar.");
			}
			return it->second;
		};
		
		terminalCount = 0;
		terminalLimit = 0;
		// First set the non-restricted terminal nodes.
		for (auto &&node : nodes) {
			if (node.isTerminal()) {
				terminalCount ++;
				terminalLimit += node.weight;
				this->nodes.push_back(node);
			}
		}
		assert(terminalCount != 0 && "Invalid GP grammar - expected at least one terminal node");
		// Then set the non-restricted function nodes.
		terminalAndFunctionCount = terminalCount;
		functionLimit = 0;
		for (auto &&node : nodes) {
			if (node.isFunction()) {
				terminalAndFunctionCount ++;
				functionLimit += node.weight;
				this->nodes.push_back(node);
			}
		}
		nodeLimit = terminalLimit + functionLimit;
		validNodeLimit = nodeLimit;
		globalDefinitionSet = TypeDefinitionSet(terminalLimit, nodeLimit, 0, terminalLimit);
		
		// Assign the type ids.
		for (auto &x : this->nodes) {
			x.typeId = findTypeId(x.typeName);
			assert(x.argumentTypeIds.empty());
			for (auto &&typeName : x.argumentTypeNames) {
				x.argumentTypeIds.push_back(findTypeId(typeName));
			}
		}
		
		// Sort the nodes by type so that they're partioned both by kind (terminal/function) and type.
		struct Comparator {
			bool operator()(const struct Definition &x, const struct Definition &y) const {
				return x.typeId < y.typeId;
			}
		};
		std::stable_sort(this->nodes.begin(), this->nodes.begin() + terminalCount, Comparator());
		std::stable_sort(this->nodes.begin() + terminalCount, this->nodes.begin() + terminalAndFunctionCount, Comparator());

		// Assign the node ids and raw values and type ids.
		unsigned nodeId = 0;
		TreeGenomeValue val = 0;
		for (auto &x : this->nodes) {
			x.nodeId = nodeId;
			x.rawValue = val;
			// FIXME: make error.
			assert(x.weight != 0);
			nodeId ++;
			val += x.weight;
		}
		
		// Create the type partions
		typePartions.resize(types.size());
		std::vector<std::pair<bool, bool>> typePartionsInitialized(types.size(), std::make_pair(false, false));
		size_t offset = 0;
		for (auto &x : this->nodes) {
			auto type = x.getType();
			if (x.isTerminal()) {
				if (!typePartionsInitialized[type].first) {
					assert(typePartions[type].terminalCount == 0);
					typePartions[type].terminalBegin = offset;
					typePartionsInitialized[type].first = true;
				}
				typePartions[type].terminalCount ++;
			} else {
				assert(x.isFunction());
				if (!typePartionsInitialized[type].second) {
					assert(typePartions[type].functionCount == 0);
					typePartions[type].functionBegin = offset;
					typePartionsInitialized[type].second = true;
				}
				typePartions[type].functionCount ++;
			}
			offset++;
		}
	
		// Compute the type definition sets.
		for (auto &&type : this->types) {
			TreeGenomeValue terminalLimit = 0;
			auto terminals = terminalsForType(type.getTypeValue());
			bool hasTerminals = false;
			for (auto &&node : terminals) {
				hasTerminals = true;
				terminalLimit += node.getWeight();
			}
			TreeGenomeValue functionLimit = terminalLimit;
			auto functions = functionsForType(type.getTypeValue());
			bool hasFunctions = false;
			for (auto &&node : functions) {
				hasFunctions = true;
				functionLimit += node.getWeight();
			}
			assert(hasFunctions && "All types must have functions");
			definitionSets.push_back(TypeDefinitionSet(terminalLimit, functionLimit, hasTerminals ? terminals.begin()->getNodeValue() : 0, hasFunctions ? functions.begin()->getNodeValue() : 0));
		}
	}

	// The number of definitions in this grammar.
	size_t size() const {
		return nodes.size();
	}

	// The number of types in this grammar.
	size_t typeCount() const {
		return types.size();
	}
	
	// All of the definitions.
	IteratorRange<std::vector<Definition>::const_iterator> definitions() const {
		return makeIteratorRange(nodes.begin(), nodes.end());
	}
	
	// All of the defined terminals of the given type.
	IteratorRange<std::vector<Definition>::const_iterator> terminalsForType(TreeGenomeType type) const {
		auto it = nodes.begin() + typePartions[type].terminalBegin;
		return makeIteratorRange(it, it + typePartions[type].terminalCount);
	}
	
	// All of the defined functions of the given type.
	IteratorRange<std::vector<Definition>::const_iterator> functionsForType(TreeGenomeType type) const {
		auto it = nodes.begin() + typePartions[type].functionBegin;
		return makeIteratorRange(it, it + typePartions[type].functionCount);
	}
	
	const TypeDefinitionSet &definitionSetForType(TreeGenomeType type) const {
		if (type == Type::invalidTypeId) {
			return globalDefinitionSet;
		}
		return definitionSets[type];
	}

	TreeGenomeType typeByName(const char *typeName) const {
		auto it = typeMappings.find(typeName);
		if (it == typeMappings.end()) {
			assert(false && "Error: type isn't present in the grammar.");
			return Type::invalidTypeId;
		}
		return it->second;
	}

	unsigned getTerminalLimit() const {
		return terminalLimit;
	}
	
	unsigned getFunctionLimit() const {
		return functionLimit;
	}
	
	unsigned getNodeLimit() const {
		return nodeLimit;
	}

	const Definition &operator [](const TreeGenome::Node &node) const {
		return nodes[definitionIdForTreeGenomeValue(node.value)];
	}

	const Definition &operator [](unsigned definitionId) const {
		assert(definitionId < nodes.size());
		return nodes[definitionId];
	}
	
	DefinitionSet operator [](const std::string &name) const {
		std::vector<unsigned> result;
		for (auto &&node : nodes) {
			if (name == node.name) {
				result.push_back(node.getDefinitionId());
			}
		}
		return DefinitionSet(result);
	}

	unsigned definitionIdForTreeGenomeValue(TreeGenomeValue rawValue) const {
		assert(rawValue < validNodeLimit);
		if (rawValue < terminalLimit) {
			// Must be a terminal.
			for (unsigned i = 0; i < terminalCount; ++i) {
				if (rawValue >= nodes[i].rawValue && rawValue < (nodes[i].rawValue + nodes[i].weight)) {
					return i;
				}
			}
		} else if (rawValue < nodeLimit) {
			// Must be a function.
			for (unsigned i = terminalCount; i < terminalAndFunctionCount; ++i) {
				if (rawValue >= nodes[i].rawValue && rawValue < (nodes[i].rawValue + nodes[i].weight)) {
					return i;
				}
			}
		}
		assert(false && "Invalid node value");
		return 0;
	}
};
	
/// A wrapper around the grammar that allows you to query a single definiton by name.
struct GrammarDefinitionAccessor {
private:
	const Grammar &grammar;
public:
	GrammarDefinitionAccessor(const Grammar &grammar) : grammar(grammar) { }

	const Definition &operator [](const std::string &name) const {
		auto set = grammar[name];
		assert(!set.isEmpty());
		return grammar[set.singleDefinition()];
	}
};

/// Defines a GP tree type.
constexpr Type type(const char *name) {
	return Type(name);
}

/// Helper functions that allow you to define a GP tree grammar.
inline Definition terminal(const char *name, const Type &type, TreeGenomeValue weight) {
	return Definition(Definition::Kind::Terminal, name, type, {}, weight, 0);
}

inline Definition function(const char *name, const Type &type, std::initializer_list<Type> argumentTypes, TreeGenomeValue weight) {
	assert(argumentTypes.size() != 0);
	return Definition(Definition::Kind::Function, name, type, argumentTypes, weight, (unsigned)argumentTypes.size());
}

inline Definition unaryFunction(const char *name, const Type &type, const Type &argumentType, TreeGenomeValue weight) {
	return Definition(Definition::Kind::Function, name, type, { argumentType }, weight, 1);
}

inline Definition binaryFunction(const char *name, const Type &type, std::initializer_list<Type> argumentTypes, TreeGenomeValue weight) {
	assert(argumentTypes.size() == 2);
	return Definition(Definition::Kind::Function, name, type, argumentTypes, weight, 2);
}

inline Definition ternaryFunction(const char *name, const Type &type, std::initializer_list<Type> argumentTypes, TreeGenomeValue weight) {
	assert(argumentTypes.size() == 3);
	return Definition(Definition::Kind::Function, name, type, argumentTypes, weight, 3);
}

} // end namespace grammar
} // end namespace genetic
